## 2.1 lua 值与类型 ##
**Lua 是一门动态类型语言。 这意味着变量没有类型；只有值才有类型。** 语言中不设类型定义。 所有的值携带自己的类型。Lua 中所有的值都是 一等公民。 这意味着所有的值均可保存在变量中、 当作参数传递给其它函数、以及作为返回值。

Lua 中有八种基本类型： nil、boolean、number、string、function、userdata、 thread 和 table。

- **Nil 是值 nil 的类型**， 其主要特征就是和其它值区别开；通常用来表示一个有意义的值不存在时的状态。
- **Boolean 是 false 与 true 两个值的类型。 nil 和 false 都会导致条件判断为假； 而其它任何值都表示为真。**
-  **Number 代表了整数和实数（浮点数）。**number 类型有两种内部表现方式， 整数 和 浮点数。 对于何时使用哪种内部形式，Lua 有明确的规则， 但它也按需作自动转换。 因此，程序员多数情况下可以选择忽略整数与浮点数之间的差异或者假设完全控制每个数字的内部表现方式。 标准 Lua 使用 64 位整数和双精度（64 位）浮点数，**但你也可以把 Lua 编译成使用 32 位整数和单精度（32 位）浮点数。 以 32 位表示数字对小型机器以及嵌入式系统特别合适。 （参见 luaconf.h 文件中的宏 LUA_32BITS 。**
-  **String 表示一个不可变的字节序列。** Lua 对 8 位是友好的： 字符串可以容纳任意 8 位值(1字节)， 其中包含零 ('\0') 。 Lua 的字符串与编码无关； 它不关心字符串中具体内容。
-  **Lua 可以调用（以及操作）用 Lua 或 C 编写的函数。 这两种函数有统一类型 function。**
-  **userdata 类型允许将 C 中的数据保存在 Lua 变量中。** 用户数据类型的值是一个内存块， 有两种用户数据： **完全用户数据** ，指一块由 Lua 管理的内存对应的对象； **轻量用户数据 ，则指一个简单的 C 指针**。 用户数据在 Lua 中除了赋值与相等性判断之外没有其他预定义的操作。 通过使用 元表 ，程序员可以给完全用户数据定义一系列的操作。 你只能通过 C API 而无法在 Lua 代码中创建或者修改用户数据的值， 这保证了数据仅被宿主程序所控制。
-  **thread 类型表示了一个独立的执行序列，被用于实现协程。** Lua 的线程与操作系统的线程毫无关系。 Lua 为所有的系统，包括那些不支持原生线程的系统，提供了协程支持。
-  **table 是一个关联数组，** 也就是说，这个数组不仅仅以数字做索引，**除了 nil 和 NaN 之外的所有 Lua 值 都可以做索引。**（Not a Number 是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 0/0。） **表可以是 异构 的**； 也就是说，表内可以包含任何类型的值（ nil 除外）。 任何键的值若为 nil 就不会被记入表结构内部。 换言之，对于表内不存在的键，都对应着值 nil 。

**表是 Lua 中唯一的数据结构， 它可被用于表示普通数组、序列、符号表、集合、记录、图、树等等。** 对于记录，Lua 使用域名作为索引。 语言提供了 a.name 这样的语法糖来替代 a["name"] 这种写法以方便记录这种结构的使用。 在 Lua 中有多种便利的方式创建表。我们使用 序列 这个术语来表示一个用 **{1..n}** 的正整数集做索引的表。 这里的非负整数 n 被称为该序列的长度）。

**和索引一样，表中每个域的值也可以是任何类型。 需要特别指出的是：既然函数是一等公民，那么表的域也可以是函数。 这样，表就可以携带 方法 了。**

索引一张表的原则遵循语言中的直接比较规则。 当且仅当 i 与 j直接比较相等时 （即不通过元方法的比较）， 表达式 a[i] 与 a[j] 表示了表中相同的元素。 **特别指出：一个可以完全表示为整数的浮点数和对应的整数相等 （例如：1.0 == 1）。** **为了消除歧义，当一个可以完全表示为整数的浮点数做为键值时， 都会被转换为对应的整数储存。 例如，当你写 a[2.0] = true 时， 实际被插入表中的键是整数 2 。 （另一方面，2 与 "2" 是两个不同的 Lua 值， 故而它们可以是同一张表中的不同项。）**

表、函数、线程、以及完全用户数据在 Lua 中被称为**对象**： 变量并不真的持有它们的值，而仅保存了对这些对象的**引用**。 **赋值、参数传递、函数返回，都是针对引用而不是针对值的操作， 这些操作均不会做任何形式的隐式拷贝。**库函数 type 用于以字符串形式返回给定值的类型。

示例代码1：

	print(type(nil))                    -- 输出 nil
	print(type(99.7+12*9))              -- 输出 number
	print(type(true))                   -- 输出 boolean
	print(type("Hello Wikipedia"))      -- 输出 string
	print(type(print))                  -- 输出 function
	print(type{1, 2, test = "test"})    -- 输出 table

示例代码2：

	local num -- 为赋值的对象都是nil
	local lock = false
	
	if(num) then
		print("num true")
	else
		print("num false")
	end 
	
	if(lock) then
		print("lock true")
	else
		print("lock false")
	end 

示例代码3：

	local tb = {}
	tb[2.0] = "hello"
	tb["string"] = 23456
	tb["2"] = "lua"
	
	for k ,v in pairs(tb) do 
		print(k.." -> "..v) -- 2.0变成2保存了
	end
	
	print("---")
	print(tb["2"]) -- 保存了不同的值
	print(tb[2.0])

示例代码4：

	local tb = {}
	table.insert(tb, 23)
	table.insert(tb, "hello lua")
	table.insert(tb, "omg")
	
	for k ,v in pairs(tb) do 
		print(k.." -> "..v)  
	end

运行结果：
 
	1 -> 23 
	2 -> hello lua
	3 -> omg

把table当做list使用时，默认key为1, 2, 3...n 

示例代码5：

	function test()
		print("hello lua")
	end
	
	local test1 = test  
	test1()

## 2.2 错误处理 ##

由于 Lua 是一门嵌入式扩展语言，其所有行为均源于宿主程序中 C 代码对某个 Lua 库函数的调用。 （单独使用 Lua 时，lua 程序就是宿主程序。） 所以，**在编译或运行 Lua 代码块的过程中，无论何时发生错误， 控制权都返回给宿主，由宿主负责采取恰当的措施（比如打印错误消息）。**

可以在 Lua 代码中调用 **error** 函数来显式地抛出一个错误。 如果你需要在 Lua 中捕获这些错误， 可以使用 **pcall 或 xpcall 在 保护模式 下调用一个函数。**

无论何时出现错误，都会抛出一个携带错误信息的错误对象（错误消息）。 Lua 本身只会为错误生成字符串类型的错误对象， 但你的程序可以为错误生成任何类型的错误对象， 这就看你的 Lua 程序或宿主程序如何处理这些错误对象。


**使用 xpcall 或 lua_pcall 时， 你应该提供一个 消息处理函数 用于错误抛出时调用。** 该函数需接收原始的错误消息，并返回一个新的错误消息。 它在错误发生后栈尚未展开时调用， 因此可以利用栈来收集更多的信息， 比如通过探知栈来创建一组栈回溯信息。 同时，该处理函数也处于保护模式下，所以该函数内发生的错误会再次触发它（递归）。 如果递归太深，Lua 会终止调用并返回一个合适的消息。

示例：

	error("lua error xxx")

运行结果：

	lua: ll.lua:1: lua error xxx
	stack traceback:
	        [C]: in function 'error'
	        ll.lua:1: in main chunk
	        [C]: in ?

 
## 2.3 垃圾收集 ##
Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。 Lua 运行了一个 **垃圾收集器** 来收集所有 死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。

## 2.4 元表及元方法 
**Lua 中的每个值都可以有一个 元表。这个 元表 就是一个普通的 Lua 表，它用于定义原始值在特定操作下的行为。 如果你想改变一个值在特定操作下的行为，你可以在它的元表中设置对应域。 例如，当你对非数字值做加操作时， Lua 会检查该值的元表中的 "__add" 域下的函数。 如果能找到，Lua 则调用这个函数来完成加这个操作。**

元表中的键对应着不同的 事件 名； 键关联的那些值被称为 **元方法**。 在上面那个例子中引用的事件为 "add" ， 完成加操作的那个函数就是元方法。

你可以用 **getmetatable** 函数 来获取任何值的元表。

**使用 setmetatable 来替换一张表的元表。** 在 Lua 中，你不可以改变表以外其它类型的值的元表 （除非你使用调试库）； 若想改变这些非表类型的值的元表，请使用 C API。

表和完全用户数据有独立的元表 （当然，多个表和用户数据可以共享同一个元表）。 其它类型的值按类型共享元表； 也就是说所有的数字都共享同一个元表， 所有的字符串共享另一个元表等等。 默认情况下，值是没有元表的， 但**字符串库在初始化的时候为字符串类型设置了元表。**

**元表决定了一个对象在数学运算、位运算、比较、连接、 取长度、调用、索引时的行为。 元表还可以定义一个函数，当表对象或用户数据对象在垃圾回收时调用它。**

接下来会给出一张元表可以控制的事件的完整列表。 每个操作都用对应的事件名来区分。 每个事件的键名用加有 __  前缀的字符串来表示； 例如 "add" 操作的键名为字符串 "__add"。 注意、Lua 从元表中直接获取元方法； **访问元表中的元方法永远不会触发另一次元方法。** 下面的代码模拟了 Lua 从一个对象 obj 中获取一个元方法的过程：

     rawget(getmetatable(obj) or {}, "__" .. event_name)
对于一元操作符（取负、求长度、位反）， 元方法调用的时候，第二个参数是个哑元，其值等于第一个参数。 这样处理仅仅是为了简化 Lua 的内部实现 （这样处理可以让所有的操作都和二元操作一致）， 这个行为有可能在将来的版本中移除。 （使用这个额外参数的行为都是不确定的。）

"add": + 操作。 如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用元方法。 首先、Lua 检查第一个操作数（即使它是合法的）， 如果这个操作数没有为 __add 事件定义元方法， Lua 就会接着检查第二个操作数。 一旦 Lua 找到了元方法， 它将把两个操作数作为参数传入元方法， 元方法的结果（调整为单个值）作为这个操作的结果。 如果找不到元方法，将抛出一个错误。

- "sub": - 操作。 行为和 "add" 操作类似。
- "mul": * 操作。 行为和 "add" 操作类似。
- "div": / 操作。 行为和 "add" 操作类似。
- "mod": % 操作。 行为和 "add" 操作类似。
- "pow": ^ （次方）操作。 行为和 "add" 操作类似。
- "unm": - （取负）操作。 行为和 "add" 操作类似。
- "idiv": // （向下取整除法）操作。 行为和 "add" 操作类似。
- "band": & （按位与）操作。 行为和 "add" 操作类似， 不同的是 Lua 会在任何一个操作数无法转换为整数时 （参见 §3.4.3）尝试取元方法。
- "bor": | （按位或）操作。 行为和 "band" 操作类似。
- "bxor": ~ （按位异或）操作。 行为和 "band" 操作类似。
- "bnot": ~ （按位非）操作。 行为和 "band" 操作类似。
- "shl": << （左移）操作。 行为和 "band" 操作类似。
- "shr": >> （右移）操作。 行为和 "band" 操作类似。
- "concat": .. （连接）操作。 行为和 "add" 操作类似， 不同的是 Lua 在任何操作数即不是一个字符串 也不是数字（数字总能转换为对应的字符串）的情况下尝试元方法。
- "len": # （取长度）操作。 如果对象不是字符串，Lua 会尝试它的元方法。 如果有元方法，则调用它并将对象以参数形式传入， 而返回值（被调整为单个）则作为结果。 如果对象是一张表且没有元方法， Lua 使用表的取长度操作（参见 §3.4.7）。 其它情况，均抛出错误。
- "eq": == （等于）操作。 和 "add" 操作行为类似， 不同的是 Lua 仅在两个值都是表或都是完全用户数据 且它们不是同一个对象时才尝试元方法。 调用的结果总会被转换为布尔量。
- "lt": < （小于）操作。 和 "add" 操作行为类似， 不同的是 Lua 仅在两个值不全为整数也不全为字符串时才尝试元方法。 调用的结果总会被转换为布尔量。
- "le": <= （小于等于）操作。 和其它操作不同， 小于等于操作可能用到两个不同的事件。 首先，像 - "lt" 操作的行为那样，Lua 在两个操作数中查找 __le 元方法。 如果一个元方法都找不到，就会再次查找 __lt事件， 它会假设 a <= b 等价于 not (b < a)。 而其它比较操作符类似，其结果会被转换为布尔量。
- "index": 索引 table[key]。 当 table 不是表或是表 table 中不存在 key 这个键时，这个事件被触发。 此时，会读出 table 相应的元方法。
尽管名字取成这样， 这个事件的元方法其实可以是一个函数也可以是一张表。 如果它是一个函数，则以 table 和 key 作为参数调用它。 如果它是一张表，最终的结果就是以 key 取索引这张表的结果。 （这个索引过程是走常规的流程，而不是直接索引， 所以这次索引有可能引发另一次元方法。）

- "newindex": 索引赋值 table[key] = value 。 和索引事件类似，它发生在 table 不是表或是表 table 中不存在 key 这个键的时候。 此时，会读出 table 相应的元方法。
同索引过程那样， 这个事件的元方法即可以是函数，也可以是一张表。 如果是一个函数， 则以 table、 key、以及 value 为参数传入。 如果是一张表， Lua 对这张表做索引赋值操作。 （这个索引过程是走常规的流程，而不是直接索引赋值， 所以这次索引赋值有可能引发另一次元方法。）

一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 rawset 来做赋值。）

- "call": 函数调用操作 func(args)。 当 Lua 尝试调用一个非函数的值的时候会触发这个事件 （即 func 不是一个函数）。 查找 func 的元方法， 如果找得到，就调用这个元方法， func 作为第一个参数传入，原来调用的参数（args）后依次排在后面。

**示例程序：**

	local mt = {}
	
	function mt.__add(t1, t2)
		for k, v in pairs(t2) do
			table.insert(t1, v)
		end
		return t1
	end
	
	local t1 = {1, 3}
	local t2 = {5, 7}
	
	setmetatable(t1, mt)
	
	local tsum = t1 + t2
	for k, v in pairs(tsum) do
		print(v)
	end

运行结果：

	1
	3
	5
	7
